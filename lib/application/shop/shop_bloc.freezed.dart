// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'shop_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');
///
/// @nodoc
mixin _$ShopEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uploadButtonClickedEvent,
    required TResult Function() alterationClickedEvent,
    required TResult Function() stitchingClickedEvent,
    required TResult Function(bool isChecked) embroidaryClickedEvent,
    required TResult Function(bool isChecked) handWorkClickedEvent,
  ashwin) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uploadButtonClickedEvent,
    TResult? Function()? alterationClickedEvent,
    TResult? Function()? stitchingClickedEvent,
    TResult? Function(bool isChecked)? embroidaryClickedEvent,
    TResult? Function(bool isChecked)? handWorkClickedEvent,
  ashwin) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uploadButtonClickedEvent,
    TResult Function()? alterationClickedEvent,
    TResult Function()? stitchingClickedEvent,
    TResult Function(bool isChecked)? embroidaryClickedEvent,
    TResult Function(bool isChecked)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_uploadButtonClickedEvent value)
        uploadButtonClickedEvent,
    required TResult Function(_alterationClickedEvent value)
        alterationClickedEvent,
    required TResult Function(_stitchingClickedEvent value)
        stitchingClickedEvent,
    required TResult Function(_embroidaryClickedEvent value)
        embroidaryClickedEvent,
    required TResult Function(_handWorkClickedEvent value) handWorkClickedEvent,
  ashwin) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_uploadButtonClickedEvent value)?
        uploadButtonClickedEvent,
    TResult? Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult? Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult? Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult? Function(_handWorkClickedEvent value)? handWorkClickedEvent,
  ashwin) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_uploadButtonClickedEvent value)? uploadButtonClickedEvent,
    TResult Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult Function(_handWorkClickedEvent value)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) =>
      throw _privateConstructorUsedError;
ashwin

/// @nodoc
abstract class $ShopEventCopyWith<$Res> {
  factory $ShopEventCopyWith(ShopEvent value, $Res Function(ShopEvent) then) =
      _$ShopEventCopyWithImpl<$Res, ShopEvent>;
ashwin

/// @nodoc
class _$ShopEventCopyWithImpl<$Res, $Val extends ShopEvent>
    implements $ShopEventCopyWith<$Res> {
  _$ShopEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
ashwin

/// @nodoc
abstract class _$$uploadButtonClickedEventImplCopyWith<$Res> {
  factory _$$uploadButtonClickedEventImplCopyWith(
          _$uploadButtonClickedEventImpl value,
          $Res Function(_$uploadButtonClickedEventImpl) then) =
      __$$uploadButtonClickedEventImplCopyWithImpl<$Res>;
ashwin

/// @nodoc
class __$$uploadButtonClickedEventImplCopyWithImpl<$Res>
    extends _$ShopEventCopyWithImpl<$Res, _$uploadButtonClickedEventImpl>
    implements _$$uploadButtonClickedEventImplCopyWith<$Res> {
  __$$uploadButtonClickedEventImplCopyWithImpl(
      _$uploadButtonClickedEventImpl _value,
      $Res Function(_$uploadButtonClickedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
ashwin

/// @nodoc

class _$uploadButtonClickedEventImpl implements _uploadButtonClickedEvent {
  const _$uploadButtonClickedEventImpl();

  @override
  String toString() {
    return 'ShopEvent.uploadButtonClickedEvent()';
  ashwin

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$uploadButtonClickedEventImpl);
  ashwin

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uploadButtonClickedEvent,
    required TResult Function() alterationClickedEvent,
    required TResult Function() stitchingClickedEvent,
    required TResult Function(bool isChecked) embroidaryClickedEvent,
    required TResult Function(bool isChecked) handWorkClickedEvent,
  ashwin) {
    return uploadButtonClickedEvent();
  ashwin

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uploadButtonClickedEvent,
    TResult? Function()? alterationClickedEvent,
    TResult? Function()? stitchingClickedEvent,
    TResult? Function(bool isChecked)? embroidaryClickedEvent,
    TResult? Function(bool isChecked)? handWorkClickedEvent,
  ashwin) {
    return uploadButtonClickedEvent?.call();
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uploadButtonClickedEvent,
    TResult Function()? alterationClickedEvent,
    TResult Function()? stitchingClickedEvent,
    TResult Function(bool isChecked)? embroidaryClickedEvent,
    TResult Function(bool isChecked)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (uploadButtonClickedEvent != null) {
      return uploadButtonClickedEvent();
    ashwin
    return orElse();
  ashwin

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_uploadButtonClickedEvent value)
        uploadButtonClickedEvent,
    required TResult Function(_alterationClickedEvent value)
        alterationClickedEvent,
    required TResult Function(_stitchingClickedEvent value)
        stitchingClickedEvent,
    required TResult Function(_embroidaryClickedEvent value)
        embroidaryClickedEvent,
    required TResult Function(_handWorkClickedEvent value) handWorkClickedEvent,
  ashwin) {
    return uploadButtonClickedEvent(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_uploadButtonClickedEvent value)?
        uploadButtonClickedEvent,
    TResult? Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult? Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult? Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult? Function(_handWorkClickedEvent value)? handWorkClickedEvent,
  ashwin) {
    return uploadButtonClickedEvent?.call(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_uploadButtonClickedEvent value)? uploadButtonClickedEvent,
    TResult Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult Function(_handWorkClickedEvent value)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (uploadButtonClickedEvent != null) {
      return uploadButtonClickedEvent(this);
    ashwin
    return orElse();
  ashwin
ashwin

abstract class _uploadButtonClickedEvent implements ShopEvent {
  const factory _uploadButtonClickedEvent() = _$uploadButtonClickedEventImpl;
ashwin

/// @nodoc
abstract class _$$alterationClickedEventImplCopyWith<$Res> {
  factory _$$alterationClickedEventImplCopyWith(
          _$alterationClickedEventImpl value,
          $Res Function(_$alterationClickedEventImpl) then) =
      __$$alterationClickedEventImplCopyWithImpl<$Res>;
ashwin

/// @nodoc
class __$$alterationClickedEventImplCopyWithImpl<$Res>
    extends _$ShopEventCopyWithImpl<$Res, _$alterationClickedEventImpl>
    implements _$$alterationClickedEventImplCopyWith<$Res> {
  __$$alterationClickedEventImplCopyWithImpl(
      _$alterationClickedEventImpl _value,
      $Res Function(_$alterationClickedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
ashwin

/// @nodoc

class _$alterationClickedEventImpl implements _alterationClickedEvent {
  const _$alterationClickedEventImpl();

  @override
  String toString() {
    return 'ShopEvent.alterationClickedEvent()';
  ashwin

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$alterationClickedEventImpl);
  ashwin

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uploadButtonClickedEvent,
    required TResult Function() alterationClickedEvent,
    required TResult Function() stitchingClickedEvent,
    required TResult Function(bool isChecked) embroidaryClickedEvent,
    required TResult Function(bool isChecked) handWorkClickedEvent,
  ashwin) {
    return alterationClickedEvent();
  ashwin

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uploadButtonClickedEvent,
    TResult? Function()? alterationClickedEvent,
    TResult? Function()? stitchingClickedEvent,
    TResult? Function(bool isChecked)? embroidaryClickedEvent,
    TResult? Function(bool isChecked)? handWorkClickedEvent,
  ashwin) {
    return alterationClickedEvent?.call();
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uploadButtonClickedEvent,
    TResult Function()? alterationClickedEvent,
    TResult Function()? stitchingClickedEvent,
    TResult Function(bool isChecked)? embroidaryClickedEvent,
    TResult Function(bool isChecked)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (alterationClickedEvent != null) {
      return alterationClickedEvent();
    ashwin
    return orElse();
  ashwin

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_uploadButtonClickedEvent value)
        uploadButtonClickedEvent,
    required TResult Function(_alterationClickedEvent value)
        alterationClickedEvent,
    required TResult Function(_stitchingClickedEvent value)
        stitchingClickedEvent,
    required TResult Function(_embroidaryClickedEvent value)
        embroidaryClickedEvent,
    required TResult Function(_handWorkClickedEvent value) handWorkClickedEvent,
  ashwin) {
    return alterationClickedEvent(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_uploadButtonClickedEvent value)?
        uploadButtonClickedEvent,
    TResult? Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult? Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult? Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult? Function(_handWorkClickedEvent value)? handWorkClickedEvent,
  ashwin) {
    return alterationClickedEvent?.call(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_uploadButtonClickedEvent value)? uploadButtonClickedEvent,
    TResult Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult Function(_handWorkClickedEvent value)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (alterationClickedEvent != null) {
      return alterationClickedEvent(this);
    ashwin
    return orElse();
  ashwin
ashwin

abstract class _alterationClickedEvent implements ShopEvent {
  const factory _alterationClickedEvent() = _$alterationClickedEventImpl;
ashwin

/// @nodoc
abstract class _$$stitchingClickedEventImplCopyWith<$Res> {
  factory _$$stitchingClickedEventImplCopyWith(
          _$stitchingClickedEventImpl value,
          $Res Function(_$stitchingClickedEventImpl) then) =
      __$$stitchingClickedEventImplCopyWithImpl<$Res>;
ashwin

/// @nodoc
class __$$stitchingClickedEventImplCopyWithImpl<$Res>
    extends _$ShopEventCopyWithImpl<$Res, _$stitchingClickedEventImpl>
    implements _$$stitchingClickedEventImplCopyWith<$Res> {
  __$$stitchingClickedEventImplCopyWithImpl(_$stitchingClickedEventImpl _value,
      $Res Function(_$stitchingClickedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
ashwin

/// @nodoc

class _$stitchingClickedEventImpl implements _stitchingClickedEvent {
  const _$stitchingClickedEventImpl();

  @override
  String toString() {
    return 'ShopEvent.stitchingClickedEvent()';
  ashwin

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$stitchingClickedEventImpl);
  ashwin

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uploadButtonClickedEvent,
    required TResult Function() alterationClickedEvent,
    required TResult Function() stitchingClickedEvent,
    required TResult Function(bool isChecked) embroidaryClickedEvent,
    required TResult Function(bool isChecked) handWorkClickedEvent,
  ashwin) {
    return stitchingClickedEvent();
  ashwin

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uploadButtonClickedEvent,
    TResult? Function()? alterationClickedEvent,
    TResult? Function()? stitchingClickedEvent,
    TResult? Function(bool isChecked)? embroidaryClickedEvent,
    TResult? Function(bool isChecked)? handWorkClickedEvent,
  ashwin) {
    return stitchingClickedEvent?.call();
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uploadButtonClickedEvent,
    TResult Function()? alterationClickedEvent,
    TResult Function()? stitchingClickedEvent,
    TResult Function(bool isChecked)? embroidaryClickedEvent,
    TResult Function(bool isChecked)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (stitchingClickedEvent != null) {
      return stitchingClickedEvent();
    ashwin
    return orElse();
  ashwin

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_uploadButtonClickedEvent value)
        uploadButtonClickedEvent,
    required TResult Function(_alterationClickedEvent value)
        alterationClickedEvent,
    required TResult Function(_stitchingClickedEvent value)
        stitchingClickedEvent,
    required TResult Function(_embroidaryClickedEvent value)
        embroidaryClickedEvent,
    required TResult Function(_handWorkClickedEvent value) handWorkClickedEvent,
  ashwin) {
    return stitchingClickedEvent(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_uploadButtonClickedEvent value)?
        uploadButtonClickedEvent,
    TResult? Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult? Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult? Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult? Function(_handWorkClickedEvent value)? handWorkClickedEvent,
  ashwin) {
    return stitchingClickedEvent?.call(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_uploadButtonClickedEvent value)? uploadButtonClickedEvent,
    TResult Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult Function(_handWorkClickedEvent value)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (stitchingClickedEvent != null) {
      return stitchingClickedEvent(this);
    ashwin
    return orElse();
  ashwin
ashwin

abstract class _stitchingClickedEvent implements ShopEvent {
  const factory _stitchingClickedEvent() = _$stitchingClickedEventImpl;
ashwin

/// @nodoc
abstract class _$$embroidaryClickedEventImplCopyWith<$Res> {
  factory _$$embroidaryClickedEventImplCopyWith(
          _$embroidaryClickedEventImpl value,
          $Res Function(_$embroidaryClickedEventImpl) then) =
      __$$embroidaryClickedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isCheckedashwin);
ashwin

/// @nodoc
class __$$embroidaryClickedEventImplCopyWithImpl<$Res>
    extends _$ShopEventCopyWithImpl<$Res, _$embroidaryClickedEventImpl>
    implements _$$embroidaryClickedEventImplCopyWith<$Res> {
  __$$embroidaryClickedEventImplCopyWithImpl(
      _$embroidaryClickedEventImpl _value,
      $Res Function(_$embroidaryClickedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isChecked = null,
  ashwin) {
    return _then(_$embroidaryClickedEventImpl(
      isChecked: null == isChecked
          ? _value.isChecked
          : isChecked // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  ashwin
ashwin

/// @nodoc

class _$embroidaryClickedEventImpl implements _embroidaryClickedEvent {
  const _$embroidaryClickedEventImpl({required this.isCheckedashwin);

  @override
  final bool isChecked;

  @override
  String toString() {
    return 'ShopEvent.embroidaryClickedEvent(isChecked: $isChecked)';
  ashwin

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$embroidaryClickedEventImpl &&
            (identical(other.isChecked, isChecked) ||
                other.isChecked == isChecked));
  ashwin

  @override
  int get hashCode => Object.hash(runtimeType, isChecked);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$embroidaryClickedEventImplCopyWith<_$embroidaryClickedEventImpl>
      get copyWith => __$$embroidaryClickedEventImplCopyWithImpl<
          _$embroidaryClickedEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uploadButtonClickedEvent,
    required TResult Function() alterationClickedEvent,
    required TResult Function() stitchingClickedEvent,
    required TResult Function(bool isChecked) embroidaryClickedEvent,
    required TResult Function(bool isChecked) handWorkClickedEvent,
  ashwin) {
    return embroidaryClickedEvent(isChecked);
  ashwin

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uploadButtonClickedEvent,
    TResult? Function()? alterationClickedEvent,
    TResult? Function()? stitchingClickedEvent,
    TResult? Function(bool isChecked)? embroidaryClickedEvent,
    TResult? Function(bool isChecked)? handWorkClickedEvent,
  ashwin) {
    return embroidaryClickedEvent?.call(isChecked);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uploadButtonClickedEvent,
    TResult Function()? alterationClickedEvent,
    TResult Function()? stitchingClickedEvent,
    TResult Function(bool isChecked)? embroidaryClickedEvent,
    TResult Function(bool isChecked)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (embroidaryClickedEvent != null) {
      return embroidaryClickedEvent(isChecked);
    ashwin
    return orElse();
  ashwin

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_uploadButtonClickedEvent value)
        uploadButtonClickedEvent,
    required TResult Function(_alterationClickedEvent value)
        alterationClickedEvent,
    required TResult Function(_stitchingClickedEvent value)
        stitchingClickedEvent,
    required TResult Function(_embroidaryClickedEvent value)
        embroidaryClickedEvent,
    required TResult Function(_handWorkClickedEvent value) handWorkClickedEvent,
  ashwin) {
    return embroidaryClickedEvent(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_uploadButtonClickedEvent value)?
        uploadButtonClickedEvent,
    TResult? Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult? Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult? Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult? Function(_handWorkClickedEvent value)? handWorkClickedEvent,
  ashwin) {
    return embroidaryClickedEvent?.call(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_uploadButtonClickedEvent value)? uploadButtonClickedEvent,
    TResult Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult Function(_handWorkClickedEvent value)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (embroidaryClickedEvent != null) {
      return embroidaryClickedEvent(this);
    ashwin
    return orElse();
  ashwin
ashwin

abstract class _embroidaryClickedEvent implements ShopEvent {
  const factory _embroidaryClickedEvent({required final bool isCheckedashwin) =
      _$embroidaryClickedEventImpl;

  bool get isChecked;

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$embroidaryClickedEventImplCopyWith<_$embroidaryClickedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
ashwin

/// @nodoc
abstract class _$$handWorkClickedEventImplCopyWith<$Res> {
  factory _$$handWorkClickedEventImplCopyWith(_$handWorkClickedEventImpl value,
          $Res Function(_$handWorkClickedEventImpl) then) =
      __$$handWorkClickedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isCheckedashwin);
ashwin

/// @nodoc
class __$$handWorkClickedEventImplCopyWithImpl<$Res>
    extends _$ShopEventCopyWithImpl<$Res, _$handWorkClickedEventImpl>
    implements _$$handWorkClickedEventImplCopyWith<$Res> {
  __$$handWorkClickedEventImplCopyWithImpl(_$handWorkClickedEventImpl _value,
      $Res Function(_$handWorkClickedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isChecked = null,
  ashwin) {
    return _then(_$handWorkClickedEventImpl(
      isChecked: null == isChecked
          ? _value.isChecked
          : isChecked // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  ashwin
ashwin

/// @nodoc

class _$handWorkClickedEventImpl implements _handWorkClickedEvent {
  const _$handWorkClickedEventImpl({required this.isCheckedashwin);

  @override
  final bool isChecked;

  @override
  String toString() {
    return 'ShopEvent.handWorkClickedEvent(isChecked: $isChecked)';
  ashwin

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$handWorkClickedEventImpl &&
            (identical(other.isChecked, isChecked) ||
                other.isChecked == isChecked));
  ashwin

  @override
  int get hashCode => Object.hash(runtimeType, isChecked);

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$handWorkClickedEventImplCopyWith<_$handWorkClickedEventImpl>
      get copyWith =>
          __$$handWorkClickedEventImplCopyWithImpl<_$handWorkClickedEventImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uploadButtonClickedEvent,
    required TResult Function() alterationClickedEvent,
    required TResult Function() stitchingClickedEvent,
    required TResult Function(bool isChecked) embroidaryClickedEvent,
    required TResult Function(bool isChecked) handWorkClickedEvent,
  ashwin) {
    return handWorkClickedEvent(isChecked);
  ashwin

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uploadButtonClickedEvent,
    TResult? Function()? alterationClickedEvent,
    TResult? Function()? stitchingClickedEvent,
    TResult? Function(bool isChecked)? embroidaryClickedEvent,
    TResult? Function(bool isChecked)? handWorkClickedEvent,
  ashwin) {
    return handWorkClickedEvent?.call(isChecked);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uploadButtonClickedEvent,
    TResult Function()? alterationClickedEvent,
    TResult Function()? stitchingClickedEvent,
    TResult Function(bool isChecked)? embroidaryClickedEvent,
    TResult Function(bool isChecked)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (handWorkClickedEvent != null) {
      return handWorkClickedEvent(isChecked);
    ashwin
    return orElse();
  ashwin

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_uploadButtonClickedEvent value)
        uploadButtonClickedEvent,
    required TResult Function(_alterationClickedEvent value)
        alterationClickedEvent,
    required TResult Function(_stitchingClickedEvent value)
        stitchingClickedEvent,
    required TResult Function(_embroidaryClickedEvent value)
        embroidaryClickedEvent,
    required TResult Function(_handWorkClickedEvent value) handWorkClickedEvent,
  ashwin) {
    return handWorkClickedEvent(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_uploadButtonClickedEvent value)?
        uploadButtonClickedEvent,
    TResult? Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult? Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult? Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult? Function(_handWorkClickedEvent value)? handWorkClickedEvent,
  ashwin) {
    return handWorkClickedEvent?.call(this);
  ashwin

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_uploadButtonClickedEvent value)? uploadButtonClickedEvent,
    TResult Function(_alterationClickedEvent value)? alterationClickedEvent,
    TResult Function(_stitchingClickedEvent value)? stitchingClickedEvent,
    TResult Function(_embroidaryClickedEvent value)? embroidaryClickedEvent,
    TResult Function(_handWorkClickedEvent value)? handWorkClickedEvent,
    required TResult orElse(),
  ashwin) {
    if (handWorkClickedEvent != null) {
      return handWorkClickedEvent(this);
    ashwin
    return orElse();
  ashwin
ashwin

abstract class _handWorkClickedEvent implements ShopEvent {
  const factory _handWorkClickedEvent({required final bool isCheckedashwin) =
      _$handWorkClickedEventImpl;

  bool get isChecked;

  /// Create a copy of ShopEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$handWorkClickedEventImplCopyWith<_$handWorkClickedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
ashwin

/// @nodoc
mixin _$ShopState {
  String get fileName => throw _privateConstructorUsedError;
  bool get isLoaded => throw _privateConstructorUsedError;
  String get alteration => throw _privateConstructorUsedError;
  bool get isAlteration => throw _privateConstructorUsedError;
  String get stitching => throw _privateConstructorUsedError;
  bool get isStitching => throw _privateConstructorUsedError;
  String get embroidary => throw _privateConstructorUsedError;
  bool get isEmbroidary => throw _privateConstructorUsedError;
  String get handWork => throw _privateConstructorUsedError;
  bool get isHandWork => throw _privateConstructorUsedError;

  /// Create a copy of ShopState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ShopStateCopyWith<ShopState> get copyWith =>
      throw _privateConstructorUsedError;
ashwin

/// @nodoc
abstract class $ShopStateCopyWith<$Res> {
  factory $ShopStateCopyWith(ShopState value, $Res Function(ShopState) then) =
      _$ShopStateCopyWithImpl<$Res, ShopState>;
  @useResult
  $Res call(
      {String fileName,
      bool isLoaded,
      String alteration,
      bool isAlteration,
      String stitching,
      bool isStitching,
      String embroidary,
      bool isEmbroidary,
      String handWork,
      bool isHandWorkashwin);
ashwin

/// @nodoc
class _$ShopStateCopyWithImpl<$Res, $Val extends ShopState>
    implements $ShopStateCopyWith<$Res> {
  _$ShopStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ShopState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = null,
    Object? isLoaded = null,
    Object? alteration = null,
    Object? isAlteration = null,
    Object? stitching = null,
    Object? isStitching = null,
    Object? embroidary = null,
    Object? isEmbroidary = null,
    Object? handWork = null,
    Object? isHandWork = null,
  ashwin) {
    return _then(_value.copyWith(
      fileName: null == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      isLoaded: null == isLoaded
          ? _value.isLoaded
          : isLoaded // ignore: cast_nullable_to_non_nullable
              as bool,
      alteration: null == alteration
          ? _value.alteration
          : alteration // ignore: cast_nullable_to_non_nullable
              as String,
      isAlteration: null == isAlteration
          ? _value.isAlteration
          : isAlteration // ignore: cast_nullable_to_non_nullable
              as bool,
      stitching: null == stitching
          ? _value.stitching
          : stitching // ignore: cast_nullable_to_non_nullable
              as String,
      isStitching: null == isStitching
          ? _value.isStitching
          : isStitching // ignore: cast_nullable_to_non_nullable
              as bool,
      embroidary: null == embroidary
          ? _value.embroidary
          : embroidary // ignore: cast_nullable_to_non_nullable
              as String,
      isEmbroidary: null == isEmbroidary
          ? _value.isEmbroidary
          : isEmbroidary // ignore: cast_nullable_to_non_nullable
              as bool,
      handWork: null == handWork
          ? _value.handWork
          : handWork // ignore: cast_nullable_to_non_nullable
              as String,
      isHandWork: null == isHandWork
          ? _value.isHandWork
          : isHandWork // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  ashwin
ashwin

/// @nodoc
abstract class _$$ShopStateImplCopyWith<$Res>
    implements $ShopStateCopyWith<$Res> {
  factory _$$ShopStateImplCopyWith(
          _$ShopStateImpl value, $Res Function(_$ShopStateImpl) then) =
      __$$ShopStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String fileName,
      bool isLoaded,
      String alteration,
      bool isAlteration,
      String stitching,
      bool isStitching,
      String embroidary,
      bool isEmbroidary,
      String handWork,
      bool isHandWorkashwin);
ashwin

/// @nodoc
class __$$ShopStateImplCopyWithImpl<$Res>
    extends _$ShopStateCopyWithImpl<$Res, _$ShopStateImpl>
    implements _$$ShopStateImplCopyWith<$Res> {
  __$$ShopStateImplCopyWithImpl(
      _$ShopStateImpl _value, $Res Function(_$ShopStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of ShopState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = null,
    Object? isLoaded = null,
    Object? alteration = null,
    Object? isAlteration = null,
    Object? stitching = null,
    Object? isStitching = null,
    Object? embroidary = null,
    Object? isEmbroidary = null,
    Object? handWork = null,
    Object? isHandWork = null,
  ashwin) {
    return _then(_$ShopStateImpl(
      fileName: null == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      isLoaded: null == isLoaded
          ? _value.isLoaded
          : isLoaded // ignore: cast_nullable_to_non_nullable
              as bool,
      alteration: null == alteration
          ? _value.alteration
          : alteration // ignore: cast_nullable_to_non_nullable
              as String,
      isAlteration: null == isAlteration
          ? _value.isAlteration
          : isAlteration // ignore: cast_nullable_to_non_nullable
              as bool,
      stitching: null == stitching
          ? _value.stitching
          : stitching // ignore: cast_nullable_to_non_nullable
              as String,
      isStitching: null == isStitching
          ? _value.isStitching
          : isStitching // ignore: cast_nullable_to_non_nullable
              as bool,
      embroidary: null == embroidary
          ? _value.embroidary
          : embroidary // ignore: cast_nullable_to_non_nullable
              as String,
      isEmbroidary: null == isEmbroidary
          ? _value.isEmbroidary
          : isEmbroidary // ignore: cast_nullable_to_non_nullable
              as bool,
      handWork: null == handWork
          ? _value.handWork
          : handWork // ignore: cast_nullable_to_non_nullable
              as String,
      isHandWork: null == isHandWork
          ? _value.isHandWork
          : isHandWork // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  ashwin
ashwin

/// @nodoc

class _$ShopStateImpl implements _ShopState {
  const _$ShopStateImpl(
      {required this.fileName,
      required this.isLoaded,
      required this.alteration,
      required this.isAlteration,
      required this.stitching,
      required this.isStitching,
      required this.embroidary,
      required this.isEmbroidary,
      required this.handWork,
      required this.isHandWorkashwin);

  @override
  final String fileName;
  @override
  final bool isLoaded;
  @override
  final String alteration;
  @override
  final bool isAlteration;
  @override
  final String stitching;
  @override
  final bool isStitching;
  @override
  final String embroidary;
  @override
  final bool isEmbroidary;
  @override
  final String handWork;
  @override
  final bool isHandWork;

  @override
  String toString() {
    return 'ShopState(fileName: $fileName, isLoaded: $isLoaded, alteration: $alteration, isAlteration: $isAlteration, stitching: $stitching, isStitching: $isStitching, embroidary: $embroidary, isEmbroidary: $isEmbroidary, handWork: $handWork, isHandWork: $isHandWork)';
  ashwin

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShopStateImpl &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.isLoaded, isLoaded) ||
                other.isLoaded == isLoaded) &&
            (identical(other.alteration, alteration) ||
                other.alteration == alteration) &&
            (identical(other.isAlteration, isAlteration) ||
                other.isAlteration == isAlteration) &&
            (identical(other.stitching, stitching) ||
                other.stitching == stitching) &&
            (identical(other.isStitching, isStitching) ||
                other.isStitching == isStitching) &&
            (identical(other.embroidary, embroidary) ||
                other.embroidary == embroidary) &&
            (identical(other.isEmbroidary, isEmbroidary) ||
                other.isEmbroidary == isEmbroidary) &&
            (identical(other.handWork, handWork) ||
                other.handWork == handWork) &&
            (identical(other.isHandWork, isHandWork) ||
                other.isHandWork == isHandWork));
  ashwin

  @override
  int get hashCode => Object.hash(
      runtimeType,
      fileName,
      isLoaded,
      alteration,
      isAlteration,
      stitching,
      isStitching,
      embroidary,
      isEmbroidary,
      handWork,
      isHandWork);

  /// Create a copy of ShopState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ShopStateImplCopyWith<_$ShopStateImpl> get copyWith =>
      __$$ShopStateImplCopyWithImpl<_$ShopStateImpl>(this, _$identity);
ashwin

abstract class _ShopState implements ShopState {
  const factory _ShopState(
      {required final String fileName,
      required final bool isLoaded,
      required final String alteration,
      required final bool isAlteration,
      required final String stitching,
      required final bool isStitching,
      required final String embroidary,
      required final bool isEmbroidary,
      required final String handWork,
      required final bool isHandWorkashwin) = _$ShopStateImpl;

  @override
  String get fileName;
  @override
  bool get isLoaded;
  @override
  String get alteration;
  @override
  bool get isAlteration;
  @override
  String get stitching;
  @override
  bool get isStitching;
  @override
  String get embroidary;
  @override
  bool get isEmbroidary;
  @override
  String get handWork;
  @override
  bool get isHandWork;

  /// Create a copy of ShopState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ShopStateImplCopyWith<_$ShopStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
ashwin
